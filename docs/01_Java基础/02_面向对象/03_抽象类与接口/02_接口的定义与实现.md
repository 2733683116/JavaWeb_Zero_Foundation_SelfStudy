# 一、接口的基本概念
接口（Interface）是 Java 中一种特殊的引用类型，用于定义**类的行为规范**，但不提供具体实现。它可以看作是一组 “功能契约”，规定了实现类必须提供哪些方法，但不关心方法如何实现。
- **核心作用**：定义统一的行为标准，实现多态和代码解耦（不同类通过实现同一接口，可被统一调用）。
- **典型场景**：描述 “能做什么”（如 “可飞行”“可支付”），而非 “是什么”（类的具体属性）。例如，Flyable接口定义fly()方法，Bird、Plane等类实现该接口表示 “具备飞行能力”。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/945835c07bb94026a0ca738a089d6d4c.png#pic_center)

# 二、接口的定义语法
## 2.1 基本定义
接口通过interface关键字定义，语法如下：

```java
[访问修饰符] interface 接口名 [extends 其他接口列表] {
    // 常量（默认public static final）
    数据类型 常量名 = 初始值;
    
    // 抽象方法（默认public abstract，JDK 8+后可定义默认方法和静态方法）
    返回值类型 方法名(参数列表);
}
```
- **interface关键字**：声明这是一个接口。
- **访问修饰符**：通常使用public（公共接口），若省略则为默认权限（仅同包可见）。
- **继承关系**：接口可通过extends继承多个其他接口（用逗号分隔），实现接口的多继承。
## 2.2 示例代码

```java
// 定义接口：可飞行的
public interface Flyable {
    // 常量（默认public static final）
    int MAX_HEIGHT = 10000; // 最大飞行高度
    
    // 抽象方法（默认public abstract）
    void fly(); // 飞行方法
    void land(); // 降落方法
}
```
## 2.3 接口的特性
1. **不能实例化**：接口无法通过new关键字创建对象，只能被类实现。

```java
// 错误：接口不能实例化
Flyable flyable = new Flyable(); 
```
2. **成员默认修饰符**：
	- **常量**：默认被public static final修饰（必须初始化，且不可修改）。
	- **抽象方法**：默认被public abstract修饰（无方法体，以分号结尾）。
	- <b>（JDK 8 + 新增）默认方法</b>：用default修饰，有方法体，供实现类直接使用或重写。
	- <b>（JDK 8 + 新增）静态方法</b>：用static修饰，属于接口本身，通过接口名调用。
3. **只能包含抽象方法和常量**：接口中不能定义成员变量（非静态非 final）、构造器或具体方法（JDK 8 + 默认方法和静态方法除外）。
#  三、接口的实现（类实现接口）
## 3.1 基本实现
类通过implements关键字实现接口，语法如下：

```java
[访问修饰符] class 类名 implements 接口名 [, 其他接口名] {
    // 实现接口中的所有抽象方法
    @Override
    返回值类型 接口方法名(参数列表) {
        // 方法体（具体实现）
    }
}
```
- **implements关键字**：表示类遵循接口定义的规范。
- **多实现**：一个类可实现多个接口（用逗号分隔），需实现所有接口的抽象方法。
## 3.2 示例代码

```java
// 实现Flyable接口的类：鸟
public class Bird implements Flyable {
    @Override
    public void fly() {
        System.out.println("鸟扇动翅膀飞行");
    }
    
    @Override
    public void land() {
        System.out.println("鸟降落在树上");
    }
}

// 实现Flyable接口的类：飞机
public class Plane implements Flyable {
    @Override
    public void fly() {
        System.out.println("飞机靠引擎飞行，最大高度：" + MAX_HEIGHT); // 使用接口常量
    }
    
    @Override
    public void land() {
        System.out.println("飞机降落在跑道上");
    }
}
```
## 3.3 关键规则
1. **必须实现所有抽象方法**：实现类必须重写接口中的所有抽象方法（除非实现类是抽象类），且方法的访问修饰符必须为public（与接口方法的默认修饰符一致）。
 - **错误示例**：
```java
class Bird implements Flyable {
    // 错误：接口方法默认public，实现时不能用更低的权限（如默认权限）
    void fly() { ... } 
}
```
- **正确示例**：
```java
class Bird implements Flyable {
    // 正确：用public修饰，与接口方法权限一致
    @Override
    public void fly() { ... } 
}
```

2. **抽象实现类**：若类未实现接口的所有抽象方法，该类必须声明为抽象类，由其子类继续实现剩余方法。

```java
// 抽象实现类（未完全实现接口方法）
public abstract class AbstractFlyer implements Flyable {
    @Override
    public void fly() {
        System.out.println("默认飞行方式");
    }
    // 未实现land()方法，因此类必须为abstract
}

// 子类实现剩余方法
public class Plane extends AbstractFlyer {
    @Override
    public void land() { // 实现AbstractFlyer未完成的方法
        System.out.println("飞机降落在跑道上");
    }
}
```

# 四、接口的核心使用场景
## 4.1 场景 1：定义行为规范，实现多态
接口作为 “行为契约”，允许不同类通过实现同一接口，被统一调用（多态特性）。

示例：

```java
// 接口：支付方式
public interface Payable {
    void pay(double amount); // 支付方法
}

// 实现类1：微信支付
public class WeChatPay implements Payable {
    @Override
    public void pay(double amount) {
        System.out.println("微信支付：" + amount + "元");
    }
}

// 实现类2：支付宝支付
public class Alipay implements Payable {
    @Override
    public void pay(double amount) {
        System.out.println("支付宝支付：" + amount + "元");
    }
}

// 统一调用（多态）
public class PaymentService {
    // 方法参数为接口类型，可接收任何实现类
    public void processPayment(Payable payable, double amount) {
        payable.pay(amount);
    }
}

// 使用
public class Test {
    public static void main(String[] args) {
        PaymentService service = new PaymentService();
        service.processPayment(new WeChatPay(), 100); // 微信支付
        service.processPayment(new Alipay(), 200); // 支付宝支付
    }
}
```
## 4.2 场景 2：实现多重继承的效果
Java 类只能单继承，但可通过实现多个接口实现 “多重继承” 的效果（继承一个类 + 实现多个接口）。

示例：

```java
// 父类：动物
class Animal {
    public void eat() {
        System.out.println("吃东西");
    }
}

// 接口1：可跑
interface Runnable {
    void run();
}

// 接口2：可游泳
interface Swimmable {
    void swim();
}

// 子类：鸭子（继承Animal，实现两个接口）
class Duck extends Animal implements Runnable, Swimmable {
    @Override
    public void run() {
        System.out.println("鸭子跑");
    }
    
    @Override
    public void swim() {
        System.out.println("鸭子游");
    }
}
```
# 五、接口的最佳实践
1. **接口名体现行为**：接口名通常用 “形容词” 或 “动词 + able” 形式（如Flyable、Payable、Runnable），明确表示 “具备某种能力”。
2. **接口职责单一**：一个接口应只定义一类行为（如Flyable只定义飞行相关方法），避免 “万能接口”（包含过多不相关方法）。
3. **依赖接口而非实现**：方法参数、变量类型优先使用接口类型，而非具体实现类，提高代码的灵活性和可替换性。

```java
// 推荐：依赖接口
public void start(Flyable flyable) {
    flyable.fly();
}

// 不推荐：依赖具体类
public void start(Bird bird) {
    bird.fly();
}
```
4. **合理使用默认方法**：JDK 8 + 的默认方法用于为接口新增功能时兼容旧实现类（无需所有实现类修改），但不宜过度使用（可能破坏接口的规范性）。
# 六、总结
接口是 Java 中定义行为规范、实现多态和代码解耦的核心机制，核心要点：
- **定义**：通过interface关键字声明，包含抽象方法和常量，不能实例化。
- **实现**：类通过implements关键字实现接口，必须重写所有抽象方法（除非是抽象类）。
- **特性**：支持多实现（一个类实现多个接口）和多继承（接口继承多个接口），默认成员有固定修饰符。
- **作用**：定义统一行为标准，实现多态，弥补类单继承的不足，降低代码耦合度。

合理使用接口能使代码结构更清晰、扩展更灵活，是 Java 面向对象编程中实现 “基于接口编程” 思想的关键。