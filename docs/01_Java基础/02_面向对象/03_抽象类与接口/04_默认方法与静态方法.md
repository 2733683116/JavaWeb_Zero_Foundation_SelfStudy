# 一、概述（默认方法与静态方法的引入）
在 JDK 8 之前，接口（Interface）中只能包含抽象方法（无方法体）和常量。这种设计存在一个明显缺陷：当需要为接口新增方法时，所有实现该接口的类都必须强制实现新方法，否则会编译错误，严重影响代码的兼容性和扩展性。

为解决这一问题，JDK 8 引入了两种新的接口方法类型：**默认方法（Default Method）** 和 **静态方法（Static Method）**。它们允许在接口中定义有方法体的方法，既保持了接口的规范性，又增强了接口的灵活性和兼容性。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/870406a671b54594b65fc71d209ef25e.png#pic_center)

# 二、默认方法（Default Method）
## 2.1 定义与语法
默认方法是接口中用 default 关键字修饰的方法，**包含方法体**，实现类可以直接继承使用，也可以根据需要重写。

**语法**：

```java
public interface 接口名 {
    // 默认方法（必须有方法体）
    default 返回值类型 方法名(参数列表) {
        // 方法体（具体实现）
    }
}
```
**示例**：

```java
// 定义接口，包含默认方法
public interface Vehicle {
    // 抽象方法（必须被实现）
    void start();
    
    // 默认方法（实现类可直接使用或重写）
    default void stop() {
        System.out.println("车辆停止");
    }
}
```
## 2.2 核心特性
1. **默认继承**：实现类无需显式实现默认方法，可直接调用接口中定义的默认实现。
**示例**：

```java
// 实现接口，未重写默认方法
public class Car implements Vehicle {
    @Override
    public void start() { // 只需实现抽象方法
        System.out.println("汽车启动");
    }
}

// 测试
public class Test {
    public static void main(String[] args) {
        Vehicle car = new Car();
        car.start(); // 调用实现的抽象方法 → 输出“汽车启动”
        car.stop(); // 调用接口的默认方法 → 输出“车辆停止”
    }
}
```
2. **可被重写**：实现类可以根据自身需求重写默认方法，覆盖接口中的默认实现。
**示例**：

```java
public class Bike implements Vehicle {
    @Override
    public void start() {
        System.out.println("自行车启动");
    }
    
    // 重写默认方法
    @Override
    public void stop() {
        System.out.println("自行车刹车停止");
    }
}

// 测试
Bike bike = new Bike();
bike.stop(); // 调用重写后的方法 → 输出“自行车刹车停止”
```
3. **访问修饰符**：默认方法的访问权限默认为 public（可省略，但不能用 private 或 protected，否则编译错误）。
## 2.3 主要作用
1. **增强接口兼容性**：为接口新增方法时，无需修改所有实现类（实现类可直接使用默认方法），解决了 “接口演进” 的问题。
例如：JDK 8 为 Collection 接口新增 forEach() 默认方法，所有集合实现类（如 ArrayList、HashMap）无需修改即可使用该方法。
2. **提供通用实现**：将多个实现类的共性逻辑提取到接口的默认方法中，减少代码冗余。
例如：Vehicle 接口的 stop() 方法提供通用停止逻辑，特殊实现类（如 Bike）可重写，普通类（如 Car）直接复用。
# 三、静态方法（Static Method）
## 3.1 定义与语法
静态方法是接口中用 static 关键字修饰的方法，**包含方法体**，属于接口本身，只能通过接口名调用，实现类不能继承或重写。

**语法**：

```java
public interface 接口名 {
    // 静态方法（必须有方法体）
    static 返回值类型 方法名(参数列表) {
        // 方法体（具体实现）
    }
}
```
**示例**：

```java
// 定义接口，包含静态方法
public interface MathUtil {
    // 静态方法（工具类逻辑）
    static int sum(int a, int b) {
        return a + b;
    }
    
    static int max(int a, int b) {
        return a > b ? a : b;
    }
}
```
## 3.2 核心特性
1. **属于接口本身**：静态方法不依赖实现类，只能通过**接口名**直接调用，不能通过实现类对象调用。
**示例**：

```java
// 正确：通过接口名调用静态方法
int result1 = MathUtil.sum(1, 2); // 结果：3
int result2 = MathUtil.max(3, 5); // 结果：5

// 错误：不能通过实现类对象调用（即使有实现类）
MathUtil util = new MathUtilImpl();
// util.sum(1, 2); // 编译错误
```
2. **不能被重写**：实现类无法重写接口的静态方法（若在实现类中定义同名方法，属于类自己的静态方法，与接口无关）。
**示例**：

```java
public class MathUtilImpl implements MathUtil {
    // 这是实现类自己的静态方法，与接口的sum()无关
    public static int sum(int a, int b) {
        return a + b + 10;
    }
}

// 调用时仍需通过接口名或类名区分
MathUtil.sum(1, 2); // 3（接口的静态方法）
MathUtilImpl.sum(1, 2); // 13（实现类的静态方法）
```
3. **访问修饰符**：静态方法的访问权限默认为 public（可省略，同样不能用 private 或 protected）。
## 3.3 主要作用
1. **提供工具类功能**：将与接口相关的工具方法定义为静态方法，避免创建专门的工具类（如 MathUtil 接口的 sum()、max() 方法）。
2. **简化接口使用**：静态方法可用于创建接口的实例（工厂方法模式），或提供接口相关的辅助逻辑。
**示例（工厂方法）**：

```java
public interface Shape {
    void draw();
    
    // 静态工厂方法：创建Circle实例
    static Shape createCircle() {
        return new Circle();
    }
}

// 使用静态方法创建实例
Shape circle = Shape.createCircle();
circle.draw();
```
# 四、默认方法与静态方法的对比
|维度	|默认方法（Default Method）	|静态方法（Static Method）|
|-|-|-|
|修饰符|	default|	static|
|所属对象|	属于实现类实例（通过实例调用）	|属于接口本身（通过接口名调用）|
|能否被重写|	能（实现类可重写）	|不能（实现类无法重写，只能定义同名的类静态方法）|
|调用方式	|通过实现类对象调用（instance.method()）	|通过接口名调用（InterfaceName.method()）|
|核心作用	|提供默认实现，增强接口兼容性|	提供工具方法或工厂方法，与接口强相关
访问接口成员	|可访问接口的其他方法（包括抽象方法和默认方法）	|只能访问接口的静态成员（常量或其他静态方法）|

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/806d452e4db54adebc83cb6946edc222.png#pic_center)


# 五、使用注意事项
1. **默认方法的设计原则**：
	- 默认方法应只提供 “通用默认实现”，避免包含复杂逻辑（否则可能限制实现类的灵活性）。
	- 若多个接口的默认方法同名，实现类必须显式重写该方法以解决冲突（本文暂不展开多接口冲突问题）。
2. **静态方法的设计原则**：
	- 静态方法应与接口的核心功能强相关，避免定义无关的工具方法。
	- 静态方法不能访问接口的抽象方法或实例成员（因不依赖实例）。
3. **接口的本质不变**：
	- 接口仍以定义抽象方法为主，默认方法和静态方法仅作为补充，不应过度使用（否则可能模糊接口与类的界限）。
# 六、总结
默认方法和静态方法是 JDK 8 为接口带来的重要增强，核心作用如下：
- **默认方法**：通过 default 修饰，为接口提供默认实现，增强接口的兼容性和扩展性，实现类可直接使用或重写。
- **静态方法**：通过 static 修饰，属于接口本身，提供工具方法或工厂方法，只能通过接口名调用，无法被重写。

合理使用这两种方法，能使接口设计更灵活、更易用，尤其在接口演进和工具类设计场景中不可或缺。