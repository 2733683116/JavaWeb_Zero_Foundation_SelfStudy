# 一、抽象类的基本概念
抽象类（Abstract Class）是一种**不能被实例化**的特殊类，用于定义某一类事物的**抽象共性**，包含未实现的抽象方法（子类必须实现）和已实现的具体方法（子类可直接复用）。

抽象类的核心作用是**为子类提供统一的模板**，强制子类实现特定方法，同时封装子类的共性逻辑，实现代码复用与规范约束。

例如，“形状（Shape）” 是抽象概念，无法直接实例化，但可定义为抽象类，包含抽象方法 “计算面积（getArea ()）”，由具体子类（圆形、矩形）实现各自的面积计算逻辑。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/146dae0a8a4943ad9d91f4409a84f1f3.png#pic_center)

# 二、抽象类的定义语法
## 2.1 基本定义
抽象类通过abstract关键字定义，语法如下：

```java
[访问修饰符] abstract class 类名 {
    // 成员变量（属性）
    [访问修饰符] 数据类型 变量名;
    
    // 具体方法（已实现）
    [访问修饰符] 返回值类型 方法名(参数列表) {
        // 方法体
    }
    
    // 抽象方法（未实现，无方法体）
    [访问修饰符] abstract 返回值类型 抽象方法名(参数列表);
}
```
- **abstract关键字**：修饰类表示抽象类，修饰方法表示抽象方法（无方法体，以分号结尾）。
- **抽象方法**：必须在抽象类中定义，子类必须重写所有抽象方法（除非子类也是抽象类）。
## 2.2 示例代码

```java
// 抽象类：形状（无法实例化）
public abstract class Shape {
    // 成员变量（共性属性）
    protected String color;
    
    // 具体方法（已实现，子类可复用）
    public void setColor(String color) {
        this.color = color;
    }
    
    // 抽象方法（未实现，强制子类实现）
    public abstract double getArea(); // 计算面积
    public abstract double getPerimeter(); // 计算周长
}
```
## 2.3 关键特性
1. **不能实例化**：抽象类无法通过new关键字创建对象，否则编译错误。

```java
// 错误：抽象类不能实例化
Shape shape = new Shape(); 
```
2. **可包含抽象方法与具体方法**：
	- 抽象方法（abstract修饰）：无方法体，强制子类实现。
	- 具体方法（无abstract修饰）：有方法体，子类可直接使用或重写。
3. **可包含构造器**：抽象类的构造器用于子类初始化时调用（子类构造器默认调用父类构造器），但不能用于实例化抽象类本身。

```java
abstract class Animal {
    public Animal() {
        System.out.println("Animal构造器被调用");
    }
}

class Dog extends Animal {
    public Dog() {
        // 隐式调用父类构造器
    }
}

// 调用子类构造器时，父类构造器会被触发
Dog dog = new Dog(); // 输出“Animal构造器被调用”
```
# 三、抽象类的使用规则
## 3.1 子类必须实现抽象方法
非抽象子类继承抽象类时，必须**重写所有抽象方法**（实现方法体），否则子类必须也声明为抽象类。

**示例（正确，子类实现抽象方法）**：

```java
// 具体子类：圆形（继承抽象类Shape）
public class Circle extends Shape {
    private double radius; // 圆形特有属性
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    // 实现抽象方法：计算圆面积
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
    
    // 实现抽象方法：计算圆周长
    @Override
    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }
}
```
**示例（正确，子类为抽象类）**：

```java
// 抽象子类：多边形（继承Shape，未实现所有抽象方法）
public abstract class Polygon extends Shape {
    // 仅实现部分抽象方法
    @Override
    public double getPerimeter() {
        // 实现周长计算逻辑
        return 0;
    }
    // 未实现getArea()，因此Polygon必须声明为abstract
}
```
## 3.2 抽象方法的访问修饰符
抽象方法的访问修饰符不能是private（否则子类无法重写），通常使用public或protected。

- **错误示例**：
```java
abstract class Test {
    // 错误：private修饰的抽象方法，子类无法重写
    private abstract void method(); 
}
```
- **正确示例**：

```java
abstract class Test {
    // 正确：protected修饰，子类可重写
    protected abstract void method(); 
}
```
## 3.3 抽象类的继承与多态
抽象类可作为父类被继承，结合多态实现灵活调用：

```java
// 抽象类作为父类，引用指向子类对象（多态）
Shape shape1 = new Circle(5); // 圆形
Shape shape2 = new Rectangle(3, 4); // 矩形

// 调用子类实现的抽象方法（多态特性）
System.out.println("圆面积：" + shape1.getArea()); 
System.out.println("矩形面积：" + shape2.getArea()); 
```
# 四、抽象类的核心使用场景
## 4.1 场景 1：定义抽象概念的模板
当某类事物存在抽象共性但无法实例化时，使用抽象类定义模板。例如：
- 抽象类Animal：包含eat()具体方法和makeSound()抽象方法，子类Dog、Cat实现makeSound()。
- 抽象类Vehicle：包含run()抽象方法，子类Car、Bike实现各自的运行逻辑。
## 4.2 场景 2：强制子类实现特定方法
抽象类通过抽象方法强制子类实现特定功能，确保子类符合某种规范。例如：
- 抽象类Payment：定义pay(double amount)抽象方法，子类WeChatPay、AliPay必须实现具体支付逻辑。
## 4.3 场景 3：封装子类的共性逻辑
抽象类中可定义具体方法封装共性逻辑，子类直接复用，减少代码冗余。例如：
- 抽象类BaseDao：包含数据库连接（connect()）、关闭连接（close()）等具体方法，子类UserDao、OrderDao直接复用，仅需实现insert()、query()等抽象方法。
# 五、抽象类的注意事项
1. **不能实例化**：抽象类无法通过new创建对象，只能作为父类被继承。
2. **抽象方法必须被重写**：非抽象子类必须重写抽象类的所有抽象方法，否则编译错误。
3. **抽象类可包含非抽象方法**：抽象类并非只能有抽象方法，可包含具体方法（如Shape的setColor()），供子类复用。
4. **final与abstract不能共存**：
	- final类不能被继承，abstract类必须被继承，两者冲突。
	- final方法不能被重写，abstract方法必须被重写，两者冲突。

**错误示例**：

```java
// 错误：final与abstract冲突
final abstract class Test {} 
```
5. **抽象类的构造器作用**：抽象类的构造器用于初始化自身的成员变量，由子类构造器调用（通过super()），而非实例化抽象类。
# 六、抽象类的最佳实践
1. **抽象类名体现抽象概念**：类名应使用抽象名词（如Shape、Animal），明确无法实例化的特性。
2. **抽象方法与具体方法分离**：
	- 抽象方法：定义子类必须实现的 “差异化” 逻辑（如getArea()）。
	- 具体方法：封装子类的 “共性” 逻辑（如setColor()），避免重复实现。
3. **控制抽象方法数量**：抽象方法不宜过多（建议≤5 个），否则子类实现成本过高，可拆分抽象类。
4. **避免过度设计**：若类可完全实例化且无需强制子类实现方法，无需定义为抽象类。
# 七、总结
抽象类是 Java 中实现代码复用与规范约束的重要机制，核心要点：
- **定义**：通过abstract关键字声明，包含抽象方法（无实现）和具体方法（有实现）。
- **特性**：不能实例化，子类必须重写所有抽象方法（除非子类也是抽象类）。
- **作用**：定义抽象概念的模板，强制子类实现特定方法，封装共性逻辑。
- **场景**：抽象概念建模、规范子类行为、减少代码冗余。

合理使用抽象类能使类的层次结构更清晰，提高代码的可维护性和扩展性，是面向对象设计中 “开闭原则” 的典型应用。
