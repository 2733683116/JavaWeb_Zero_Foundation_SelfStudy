# 一、封装的基本概念
封装（Encapsulation）是 Java 面向对象编程的三大特性之一（封装、继承、多态），指**将类的属性和方法隐藏在类内部，仅通过公开的接口（方法）与外部交互**。
- **核心思想**：“隐藏细节，暴露接口”，即禁止外部直接访问类的内部状态，而是通过预先定义的方法操作数据，确保数据的安全性和合法性。
- **形象比喻**：如同一个 “黑盒子”，外部只能看到输入和输出（公开方法），看不到内部的运作逻辑（私有属性和实现细节）。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1877e501616240478bffdc8d62856b62.png#pic_center)

# 二、封装的核心实现方式：属性私有化 + 方法公开
封装的核心实现手段是**属性私有化（private修饰）** 和**访问方法公开（public修饰的getter/setter方法）**，具体规则如下：
1. **属性私有化**：用private修饰类的成员变量，禁止外部直接访问。
2. **方法公开**：提供public修饰的getter方法（获取属性值）和setter方法（设置属性值），作为外部操作属性的唯一接口。
## 2.1 完整示例代码

```java
// 封装的典型实现：Person类
public class Person {
    // 1. 属性私有化（private修饰，外部无法直接访问）
    private String name; // 姓名
    private int age;     // 年龄

    // 2. 公开的getter方法：获取属性值
    public String getName() {
        return name;
    }

    // 3. 公开的setter方法：设置属性值（可添加校验逻辑）
    public void setName(String name) {
        // 可选：添加参数校验，确保数据合法
        if (name != null && !name.isEmpty()) {
            this.name = name;
        } else {
            System.out.println("姓名不能为空");
        }
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        // 可选：添加参数校验（年龄必须在0-150之间）
        if (age >= 0 && age <= 150) {
            this.age = age;
        } else {
            System.out.println("年龄必须在0-150之间");
        }
    }
}
```
## 2.2 外部如何使用封装类

外部只能通过getter和setter方法操作属性，无法直接访问私有属性：

```java
public class Test {
    public static void main(String[] args) {
        Person person = new Person();

        // 错误：无法直接访问私有属性
        // person.name = "张三"; 
        // person.age = 20;

        // 正确：通过公开的setter方法设置属性
        person.setName("张三"); // 调用setter设置姓名
        person.setAge(20);     // 调用setter设置年龄

        // 正确：通过公开的getter方法获取属性
        System.out.println("姓名：" + person.getName()); // 输出“张三”
        System.out.println("年龄：" + person.getAge());   // 输出“20”
    }
}
```
## 2.3 getter/setter方法的命名规范
- **getter方法**：用于获取属性值，命名格式为get + 属性名（首字母大写），返回值类型与属性类型一致。
	- 示例：name的getter为getName()，age的getter为getAge()。
	- 特殊：boolean类型的getter通常命名为is + 属性名（如isMarried()而非getMarried()）。
- **setter方法**：用于设置属性值，命名格式为set + 属性名（首字母大写），参数类型与属性类型一致，返回值通常为void。
	- 示例：name的setter为setName(String name)，age的setter为setAge(int age)。

# 三、封装的核心优势
## 3.1 控制数据访问，确保数据合法性
setter方法中可添加参数校验逻辑，防止无效或非法数据进入类内部，保障数据的安全性。

**示例（年龄校验）**：

```java
public void setAge(int age) {
    // 只允许年龄在0-150之间，否则提示错误
    if (age >= 0 && age <= 150) {
        this.age = age;
    } else {
        throw new IllegalArgumentException("年龄必须在0-150之间");
    }
}
```
若外部传入age = 200，setter方法会直接抛出异常，避免非法数据被存储。
## 3.2 隐藏实现细节，降低耦合度
外部只需通过getter/setter方法操作属性，无需关心类内部的实现细节（如属性的存储方式、计算逻辑）。当类内部实现修改时（如属性名变更），只需同步修改getter/setter方法，外部代码无需改动，降低了代码间的依赖。

**示例（内部实现修改不影响外部）**：

```java
public class Person {
    // 内部修改：属性名从name改为fullName
    private String fullName;

    // 外部调用的方法名不变，仅内部实现修改
    public String getName() {
        return fullName; // 内部属性名变了，但外部调用方式不变
    }

    public void setName(String name) {
        this.fullName = name;
    }
}
```
## 3.3 提高代码可维护性
封装将类的属性和操作逻辑集中在类内部，便于统一管理和修改。例如，若需要对 “姓名” 添加统一的格式处理（如首字母大写），只需修改setName方法：

```java
public void setName(String name) {
    if (name != null && !name.isEmpty()) {
        // 统一处理：首字母大写
        this.name = name.substring(0, 1).toUpperCase() + name.substring(1);
    }
}
```
所有通过setName设置姓名的地方都会自动应用该逻辑，无需逐个修改外部代码。
## 3.4 实现只读 / 只写属性
通过控制getter/setter的可见性，可实现 “只读” 或 “只写” 属性：
- **只读属性**：只提供getter方法，不提供setter方法（如身份证号，一旦设置不可修改）。

```java
private String idCard; // 身份证号（只读）

public String getIdCard() {
    return idCard;
}

// 不提供setIdCard方法，外部只能通过构造器初始化
public Person(String idCard) {
    this.idCard = idCard;
}
```
- **只写属性**：只提供setter方法，不提供getter方法（如密码，设置后不允许直接获取）。

```java
private String password; // 密码（只写）

public void setPassword(String password) {
    this.password = password; // 实际开发中应加密存储
}
```

# 四、封装的最佳实践
1. **所有属性私有化**：类的成员变量必须用private修饰，禁止使用public/protected/ 默认权限（除非有特殊理由）。
2. **getter/setter按需设计**：
	- 必要时才提供getter/setter（如工具类的常量可能无需setter）。
	- setter方法专注于属性设置，避免包含复杂业务逻辑（复杂逻辑应封装在专门的业务方法中）。
3. **构造器初始化不可变属性**：对于创建后不应修改的属性（如id、birthDate），应通过构造器初始化，而非setter方法。

```java
public class Student {
    private final String id; // 学号（不可变）
    private String name;
    
    // 构造器初始化不可变属性
    public Student(String id) {
        this.id = id;
    }
    
    public String getId() {
        return id; // 只提供getter，无setter
    }
}
```
4. **避免在getter/setter中暴露内部引用**：对于引用类型属性（如List、自定义对象），getter方法应返回副本而非原对象，防止外部修改内部状态。
示例（安全的集合返回）：

```java
private List<String> hobbies = new ArrayList<>();

// 错误：返回原集合，外部可直接修改
// public List<String> getHobbies() {
//     return hobbies;
// }

// 正确：返回集合副本，保护内部状态
public List<String> getHobbies() {
    return new ArrayList<>(hobbies); // 返回新集合
}
```
# 五、总结
封装是 Java 面向对象编程的基础特性，通过**属性私有化（private）** 和**方法公开（public的getter/setter）** 实现，核心价值在于：
- **数据安全**：通过setter校验确保数据合法。
- **低耦合**：隐藏内部实现，降低外部依赖。
- **可维护性**：集中管理属性操作，便于修改和扩展。

遵循封装原则能使代码更健壮、更易维护，是编写高质量 Java 代码的基本要求。