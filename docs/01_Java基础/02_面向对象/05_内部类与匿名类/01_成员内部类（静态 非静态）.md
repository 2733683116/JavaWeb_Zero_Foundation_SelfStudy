# 一、成员内部类的基本概念
成员内部类是**定义在外部类内部**，**作为外部类成员**的类（区别于局部内部类 —— 定义在方法或代码块中的类）。它与外部类的成员（属性、方法）处于同一级别，可被访问修饰符（public/private/protected/ 默认）修饰，根据是否被static修饰，分为**非静态成员内部类**和**静态成员内部类**。

成员内部类的核心作用是**实现类的逻辑分组**（将相关类嵌入外部类，隐藏实现细节），尤其适合仅在外部类内部使用的辅助类。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e147bf1eaab348ee9cc629e425557cb9.png#pic_center)

# 二、非静态成员内部类（Non-static Member Inner Class）
## 2.1 定义与基本语法
非静态成员内部类是**未被static修饰**的成员内部类，依赖于外部类的实例存在，与外部类实例紧密关联。

**定义语法**：

```java
public class 外部类名 {
    // 外部类成员（属性、方法）
    
    // 非静态成员内部类（作为外部类成员）
    [访问修饰符] class 内部类名 {
        // 内部类的属性和方法
    }
}
```
**示例代码**：

```java
// 外部类
public class Outer {
    private String outerField = "外部类属性";
    private static String staticOuterField = "外部类静态属性";

    // 非静态成员内部类
    public class Inner {
        private String innerField = "内部类属性";

        // 内部类方法
        public void innerMethod() {
            System.out.println("访问外部类非静态属性：" + outerField); // 合法
            System.out.println("访问外部类静态属性：" + staticOuterField); // 合法
            System.out.println("访问内部类属性：" + innerField);
        }
    }
}
```
## 2.2 核心特点
1. **依赖外部类实例**：
	- 非静态内部类的创建必须依赖外部类实例，不能脱离外部类实例单独存在（类似外部类的非静态方法依赖实例）。
2. **可访问外部类的所有成员**：
	- 包括外部类的非静态成员、静态成员，甚至私有成员（private修饰）。
3. **外部类访问内部类的限制**：
	- 外部类不能直接访问内部类的成员，必须通过内部类的实例访问。
	- 示例（外部类访问内部类）：
```java
public class Outer {
    // 外部类方法访问内部类
    public void outerMethod() {
        // 必须先创建内部类实例
        Inner inner = new Inner();
        System.out.println("外部类访问内部类属性：" + inner.innerField);
        inner.innerMethod();
    }

    // 非静态内部类
    public class Inner {
        private String innerField = "内部类属性";
        public void innerMethod() {}
    }
}
```
## 2.3 创建与使用方式
创建非静态内部类的实例，需**先创建外部类实例**，再通过外部类实例创建内部类实例：

**语法**：

```java
// 步骤1：创建外部类实例
外部类名 外部类对象 = new 外部类名();
// 步骤2：通过外部类实例创建内部类实例
外部类名.内部类名 内部类对象 = 外部类对象.new 内部类名();
```
**示例**：

```java
public class Test {
    public static void main(String[] args) {
        // 1. 创建外部类实例
        Outer outer = new Outer();
        // 2. 通过外部类实例创建内部类实例
        Outer.Inner inner = outer.new Inner();
        // 3. 调用内部类方法
        inner.innerMethod();
    }
}
```
# 三、静态成员内部类（Static Member Inner Class）
## 3.1 定义与基本语法
静态成员内部类是**被static修饰**的成员内部类，属于外部类本身（不依赖外部类实例），类似外部类的静态成员。

**定义语法**：

```java
public class 外部类名 {
    // 外部类成员（属性、方法）
    
    // 静态成员内部类（作为外部类的静态成员）
    [访问修饰符] static class 内部类名 {
        // 内部类的属性和方法
    }
}
```
**示例代码**：

```java
// 外部类
public class Outer {
    private String outerField = "外部类非静态属性";
    private static String staticOuterField = "外部类静态属性";

    // 静态成员内部类
    public static class StaticInner {
        private String innerField = "静态内部类属性";
        private static String staticInnerField = "静态内部类静态属性";

        // 静态内部类方法
        public void innerMethod() {
            // 错误：静态内部类不能访问外部类的非静态属性
            // System.out.println(outerField); 
            
            // 正确：可访问外部类的静态属性
            System.out.println("访问外部类静态属性：" + staticOuterField);
            System.out.println("访问内部类非静态属性：" + innerField);
        }

        // 静态内部类的静态方法
        public static void staticInnerMethod() {
            System.out.println("静态内部类静态方法，访问内部类静态属性：" + staticInnerField);
        }
    }
}
```
## 3.2 核心特点
1. **不依赖外部类实例**：
静态内部类属于外部类本身，创建实例无需先创建外部类实例，类似外部类的静态方法。
2. **仅能访问外部类的静态成员**：
不能访问外部类的非静态成员（非静态成员依赖外部类实例，而静态内部类不依赖），但可访问外部类的静态成员（包括私有静态成员）。
3. **可包含静态成员**：
静态内部类中可以定义静态属性和静态方法（非静态内部类不能包含静态成员，编译错误）。
## 3.3 创建与使用方式
静态内部类的创建**无需外部类实例**，直接通过 “外部类名。内部类名” 访问：

**语法**：

```java
// 创建静态内部类实例（无需外部类实例）
外部类名.内部类名 内部类对象 = new 外部类名.内部类名();

// 访问静态内部类的静态成员（无需实例）
外部类名.内部类名.静态成员;
```
**示例**：

```java
public class Test {
    public static void main(String[] args) {
        // 1. 创建静态内部类实例（无需外部类实例）
        Outer.StaticInner staticInner = new Outer.StaticInner();
        staticInner.innerMethod();

        // 2. 访问静态内部类的静态方法（无需实例）
        Outer.StaticInner.staticInnerMethod();
    }
}
```
# 四、非静态与静态成员内部类的核心区别
|对比维度	|非静态成员内部类	|静态成员内部类|
|-|-|-|
|修饰符|	无static修饰	|有static修饰|
|依赖外部类实例	|依赖（必须通过外部类实例创建）|	不依赖（直接通过外部类名创建）|
|访问外部类成员	|可访问所有成员（静态 + 非静态，包括私有）	|仅可访问静态成员（包括私有静态）|
|包含静态成员的能力	|不能包含静态属性 / 方法（编译错误）|	可以包含静态属性 / 方法|
|创建实例的语法|	外部类实例.new 内部类名()	|new 外部类名.内部类名()|
|外部类访问内部类的方式	|需通过内部类实例（new Inner()）	|可直接通过类名访问静态成员（StaticInner.静态方法()）|
|典型使用场景	|与外部类实例强关联的辅助类（如Map.Entry）|	独立于外部类实例的工具类（如外部类的静态辅助逻辑）|

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ded3d20c1e454077b09ade3bf89769b6.png#pic_center)

# 五、成员内部类的访问修饰符
成员内部类作为外部类的成员，可被访问修饰符修饰，控制其可见性：
- **public**：可在任何地方访问（如Outer.Inner）。
- **private**：仅外部类内部可访问（隐藏内部实现，最常用）。
- **protected**：仅外部类、同包类、子类可访问。
- **默认（无修饰符）**：仅同包类可访问。

**示例（私有非静态内部类）**：

```java
public class Outer {
    // 私有内部类：仅Outer内部可访问
    private class PrivateInner {
        public void method() {
            System.out.println("私有内部类方法");
        }
    }

    // 外部类内部可访问私有内部类
    public void useInner() {
        PrivateInner inner = new PrivateInner();
        inner.method(); // 合法
    }
}

// 其他类中无法访问PrivateInner
public class Other {
    public void test() {
        // 错误：PrivateInner是private，Other不可访问
        // Outer.PrivateInner inner = new Outer().new PrivateInner();
    }
}
```
# 六、使用注意事项
1. 非静态内部类的this关键字：
	- 内部类中this表示内部类实例，若需访问外部类实例，用外部类名.this。
	- **示例**：
```java
public class Outer {
    private String name = "Outer";
    
    public class Inner {
        private String name = "Inner";
        
        public void printName() {
            System.out.println(this.name); // 内部类的name："Inner"
            System.out.println(Outer.this.name); // 外部类的name："Outer"
        }
    }
}
```
2. **避免循环依赖**：
非静态内部类与外部类实例相互引用可能导致内存泄漏（如内部类被长期持有，外部类实例无法回收），需谨慎使用。
3. **静态内部类的独立性**：
静态内部类应尽量独立于外部类，避免过度依赖外部类的静态成员，否则可能失去 “静态” 的意义。
# 七、总结
成员内部类是定义在外部类内部的成员级类，分为非静态和静态两种：
- **非静态成员内部类**：依赖外部类实例，可访问外部类所有成员，适合与外部类实例强关联的辅助逻辑。
- **静态成员内部类**：不依赖外部类实例，仅访问外部类静态成员，适合独立于外部类实例的工具类。

合理使用成员内部类可增强代码的封装性和逻辑性，但需注意两者的依赖关系和访问规则，避免滥用导致代码复杂度上升。