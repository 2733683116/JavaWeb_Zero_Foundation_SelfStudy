# 一、局部内部类（Local Inner Class）
## 1.1 定义与基本概念
局部内部类是**定义在方法**、**构造器**或**代码块内部**的类，其作用域仅限于所在的局部范围（定义它的方法、构造器或代码块），超出该范围则无法访问。

它的核心价值是**封装局部逻辑**—— 将仅在特定方法内使用的辅助类隐藏在方法内部，避免类名污染和逻辑暴露，同时提高代码的内聚性。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3cccc33b665c4143bce09ed16ab91b12.png#pic_center)

## 1.2 语法与示例
**定义语法**：

```java
public class 外部类名 {
    // 外部类成员（属性、方法）
    
    [访问修饰符] 返回值类型 外部类方法名(参数列表) {
        // 方法内的局部变量（可被内部类访问，需为final或有效final）
        final int localVar = 10;
        
        // 局部内部类定义（无访问修饰符，可被final/abstract修饰）
        class 局部内部类名 {
            // 内部类属性
            private int innerField = 20;
            
            // 内部类方法
            public void innerMethod() {
                // 可访问外部类属性、方法内局部变量、自身属性
                System.out.println("外部类属性：" + outerField);
                System.out.println("方法局部变量：" + localVar);
                System.out.println("内部类属性：" + innerField);
            }
        }
        
        // 仅在当前方法内使用局部内部类
        局部内部类名 实例 = new 局部内部类名();
        实例.innerMethod();
    }
    
    // 外部类属性
    private int outerField = 30;
}
```
**示例代码**：

```java
public class Outer {
    private int outerData = 100; // 外部类属性

    public void calculate() {
        final int factor = 2; // 方法内局部变量（有效final）
        
        // 定义局部内部类（仅在calculate()内可见）
        class Calculator {
            private int num;
            
            public Calculator(int num) {
                this.num = num;
            }
            
            // 内部类方法：使用外部类属性和方法局部变量
            public int multiply() {
                return num * factor * outerData; // 合法访问
            }
        }
        
        // 在方法内使用局部内部类
        Calculator calc = new Calculator(5);
        System.out.println("计算结果：" + calc.multiply()); // 输出：5*2*100=1000
    }

    public static void main(String[] args) {
        new Outer().calculate();
    }
}
```
## 1.3 核心特点
1. **作用域有限**：
	- 仅在定义它的方法、构造器或代码块内可见，外部类的其他方法或外部类之外的代码无法访问该类。
2. **访问局部变量的限制**：
	- 只能访问所在局部范围中被final修饰或 “有效 final” 的变量（“有效 final” 指变量声明后未被修改，Java 8 + 自动识别）。
	- 原因：局部变量在方法执行结束后会销毁，而内部类实例可能通过外部引用延长生命周期，final保证变量值在内部类中始终一致。
3. **无访问修饰符**：
	- 局部内部类不能被public、private、protected等访问修饰符修饰（因作用域已被局部范围限制），但可被abstract或final修饰。
4. **可完整定义类结构**：
	- 与普通类一样，可包含属性、方法、构造器，甚至实现接口或继承类（支持多接口实现）。
## 1.4 适用场景
- 方法内需要拆分复杂逻辑（如计算、转换等），且拆分出的逻辑仅为当前方法服务。
- 希望隐藏类的实现细节（类名和逻辑仅在方法内可见，外部无需关心）。
# 二、匿名内部类（Anonymous Inner Class）
## 2.1 定义与基本概念
匿名内部类是**没有类名的局部内部类**，它在创建时直接通过new关键字实例化，常用于快速实现接口或继承类，简化 “仅使用一次的简单类” 的定义流程。

它的核心价值是**简化代码**—— 无需显式定义类名，而是在使用时直接编写实现逻辑，尤其适合临时需要一个简单接口实现或类继承的场景。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1ad02b24b5644792a814da89f7cd3c00.png#pic_center)

## 2.2 语法与示例
**定义语法（两种常见形式）**：

1. **实现接口**：

```java
接口名 变量名 = new 接口名() {
    // 实现接口的所有抽象方法
};
```
2. **继承类**：

```java
父类名 变量名 = new 父类名(构造器参数) {
    // 重写父类的方法
};
```
**示例代码（实现接口）**：

```java
// 定义接口
interface Printer {
    void print(String content);
}

public class Outer {
    public void printMessage() {
        // 创建匿名内部类（实现Printer接口，无类名）
        Printer printer = new Printer() {
            // 实现接口方法
            @Override
            public void print(String content) {
                System.out.println("打印内容：" + content);
            }
        };
        
        // 使用匿名内部类实例
        printer.print("Hello, 匿名内部类");
    }

    public static void main(String[] args) {
        new Outer().printMessage(); // 输出：打印内容：Hello, 匿名内部类
    }
}
```
**示例代码（继承类）**：

```java
// 定义父类
class Animal {
    public void makeSound() {
        System.out.println("动物发声");
    }
}

public class Outer {
    public void animalSound() {
        // 创建匿名内部类（继承Animal类）
        Animal cat = new Animal() {
            // 重写父类方法
            @Override
            public void makeSound() {
                System.out.println("猫喵喵叫");
            }
        };
        
        cat.makeSound(); // 输出：猫喵喵叫
    }
}
```
## 2.3 核心特点
1. **无类名，直接实例化**：
	- 匿名内部类通过new 接口/父类() { ... }语法创建，类名由编译器自动生成（如Outer$1），开发者无需关心。
2. **仅能实现一个接口或继承一个类**：
	- 无法同时实现多个接口和继承类（因语法限制），且必须实现接口的所有抽象方法或重写父类的必要方法。
3. **无构造器**：
	- 因无类名，无法定义构造器，如需初始化可使用实例初始化块（{ ... }）。
	- 示例：
```java
Printer printer = new Printer() {
    private int count;
    
    // 实例初始化块（替代构造器）
    {
        count = 0;
        System.out.println("初始化计数器");
    }
    
    @Override
    public void print(String content) {
        count++;
        System.out.println("第" + count + "次打印：" + content);
    }
};
```
4. **作用域与局部内部类一致**：
	- 定义在方法、构造器或代码块内，作用域仅限于局部范围，访问局部变量需满足final约束。
5. **一次性使用**：
	- 匿名内部类实例通常在创建后直接使用，很少作为返回值或赋值给全局变量（因类型为接口或父类，可能丢失特有逻辑）。
## 2.4 适用场景
临时需要一个简单的接口实现（如Runnable、Comparator等），且逻辑简单（一两行代码）。
避免为一次性使用的类单独定义文件（简化代码结构）。
# 三、局部内部类与匿名内部类的对比
|维度	|局部内部类|	匿名内部类|
|-|-|-|
|类名	|有显式类名（如LocalInner）|	无类名（编译器生成临时名称）|
|定义与实例化	|先定义类，再通过类名创建实例（new 类名()）|	定义时直接实例化（new 接口/父类() { ... }）|
|构造器|	可定义构造器|	无构造器（可用实例初始化块替代）|
|实现 / 继承能力	|可实现多个接口或继承一个类|	仅能实现一个接口或继承一个类|
|复用性|	可在所在局部范围多次创建实例（可复用）|	通常仅创建一个实例（一次性使用）|
|代码复杂度	|适合稍复杂逻辑（多方法、多属性）|	适合简单逻辑（单方法实现）|
|变量类型	|可直接用自身类名作为变量类型（LocalInner）|	变量类型为接口或父类（如Printer、Animal）|
# 四、使用注意事项
1. **局部变量的final约束**：
	- 两种内部类访问局部变量时，变量必须是final或有效 final（未被修改），否则编译错误。若需修改局部变量的值，可将其封装为对象的属性（对象引用可不变）。
2. **避免逻辑复杂**：
	- 局部内部类和匿名内部类均为局部性类，若逻辑复杂（如多个方法、大量属性），建议改为独立类或成员内部类，否则会降低代码可读性。
3. **匿名内部类的类型限制**：
	- 匿名内部类的引用类型为所实现的接口或继承的父类，因此无法直接调用内部类中新增的方法（需强制类型转换，不推荐）。
	- 示例（不推荐）：
```java
Runnable r = new Runnable() {
    @Override
    public void run() {}
    public void extraMethod() {} // 新增方法
};
// 错误：Runnable接口中无extraMethod()
// r.extraMethod(); 
```
4. 内存泄漏风险：
	- 若内部类实例被外部长期引用（如赋值给静态变量），可能导致外部类实例或局部变量无法被垃圾回收，引发内存泄漏（尤其非静态方法中的内部类）。
# 五、总结
局部内部类和匿名内部类均为定义在局部范围的内部类，核心用于封装局部逻辑，但适用场景不同：
- **局部内部类**：有类名、可复用、支持复杂逻辑，适合方法内需要拆分且重复使用的辅助类。
- **匿名内部类**：无类名、一次性、简化代码，适合简单的接口实现或类继承（仅使用一次）。

合理使用两者可提高代码的内聚性和可读性，但需注意局部变量的final约束和逻辑复杂度的控制，避免过度使用导致代码维护困难。